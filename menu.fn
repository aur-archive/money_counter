#-Функция отрисовки пунктов меню---------------------------------------------------------------------------------------------------------------------------------------------------
_PRINT () {
  COUNT_MENU=`echo "${TEXT}" | wc -l`                           # определяем количество пунктов меню
  COUNT_MENU=$((${COUNT_MENU}+1-1))                             # хрень лдя красявости
  clear                                                         # очистим экран
  echo "`date +%d.%m.%Y` `date +%H:%M`      ${UP}"              # напечатаем дату/время старта и заголовок
  echo '----------------------------------------------------------------------------'
  for ((x=1;x<=${COUNT_MENU};x++))                              # х принимает значения номеров строк меню
    do                                                            # делаем
      echo "  ${x}." `echo "${TEXT}" | awk "NR==${x} {print}"`      # выводим номер пункта меню и текст подписи
    done                                                          # увеличиваем х
  echo "  0. Выход"                                             # последней строкой выводим пункт 0 - выход.
  echo                                                          # пусть будет
}
#-Функция вывода курсора-----------------------------------------------------------------------------------------------------------------------------------------------------------
_CURSOR () {
  echo '  '                                                     # это нужно для стирания предыдущего курсора
  tput cup ${LINE} 0                                            # поместим курсор в нужную позицию
  tput sc                                                       # запомним местоположение
  echo '->'                                                     # нарисуем курсор
  tput rc                                                       # вернем курсор в позицию, которую запомнили
}
#-Функция определения нажатой клавиши----------------------------------------------------------------------------------------------------------------------------------------------
_KEY () {
  stty -echo                                                    # отключение вывода печати на терминал (дабы не отображать на экране код нажатой клавиши)
  read -n3 ARROW                                                # читаем в переменную код клавиши (большинство кодов спец. клавиш состоят из 3-х символов)
  stty echo                                                     # вернем печать на экран
  ARROW=`echo -n ${ARROW} | cut -c 3`                           # определяющим клавишу символом является последний (третий)
}
#-Функция передвижения по пунктам меню---------------------------------------------------------------------------------------------------------------------------------------------
_GO () {
  case ${ARROW} in                                              # для зачения переменной кода клавиши в пределах:
    A)                                                            # А (нажата стрелка вверх)
      if [ ${LINE} -eq 2 ]                                          # если номер выбранной строки равен 2 (пункт 1)
        then                                                          # то
          LINE=$((${COUNT_MENU}+2))                                     # номер выбранной строки становится на 2 больше, чем количество пунктов меню
          STEP=0                                                        # выбранный пункт = 0 (выход)
        else                                                          # иначе
          LINE=$((${LINE}-1))                                           # номер выбранной строки уменьшается на 1
          STEP=$((${STEP}-1))                                           # номер выбранного пункта уменьшается на 1
          [ ${STEP} -eq '-1' ] && STEP=${COUNT_MENU}                    # если номер выбранного пункта стал отрицательным, то мы выбрали последний пункт 
									# (его номер совпадает с количеством пунктов меню)
      fi                                                            # конец условия
      ;;                                                            # обязательная хренотень
    B)                                                            # В (нажата стрелка вниз)
      if [ ${LINE} -eq $((${COUNT_MENU}+2)) ]                       # если номер выбранной строки больше количества пуктов меню на 2
        then                                                          # то
          LINE=2                                                        # номер выбранной строки равен 2
          STEP=1                                                        # номер выбранного пункта равен 1
        else                                                          # иначе
          LINE=$((${LINE}+1))                                           # номер выбранной строки увеличивается на 1
          STEP=$((${STEP}+1))                                           # номер выбранного пункта увеличивается на 1
          [ ${STEP} -eq $((${COUNT_MENU}+1)) ] && STEP=0                # если номер выбранного пункта стал больше количества пунктов меню на 1, то выбран пункт 0 (выход)
      fi;;                                                          # конец условия и обязательная хрень
    C);;                                                          # задатки для стрелки вправо
    D);;                                                          # задатки для стрелки влево
    *);;                                                          # прочие клавиши
  esac                                                          # конец выборки
  COMMENT=`echo "${TEXT}" | awk "NR==${STEP} {print}"`          # определяем подпись выбранного пункта
}
#-функция обязательного выбора одного из пунктов меню------------------------------------------------------------------------------------------------------------------------------
_CASE () {
  while [ "${ARROW}" != '' ]                                  # до тех пор, пока переменная не пуста (пока не нажат ENTER)
    do                                                          # делаем
      tput cup $((${COUNT_MENU}+5)) 0                             # помещаем курсор под наше меню
      echo "Ваш выбор: ${STEP}"                                   # выводим строку, дублирующую наш выбор
      tput rc                                                     # возвращаем курсор обратно
      _KEY                                                        # определяем нажатую клавишу
      _GO                                                         # двигаем курсор и меняем номер выбранного пункта
      _CURSOR                                                     # отрисовываем курсор
    done                                                        # конец цикла
}
#-Функция очистки временного файла от ненужных строк-------------------------------------------------------------------------------------------------------------------------------
_CLEAR () {
  sed '$d' ${TMP_MENU} | sed '$d' | sed '$d' | sed '$d' | sed '$d' | sed '$d' > ${TMP_MENU_1} # возьмем временный файл без последних 6 строк и запихаем во второй временный файл
  cat ${TMP_MENU_1} > ${TMP_MENU}                                                             # перепишем полученное обратно
  rm ${TMP_MENU_1}                                                                            # удалим нафиг второй временный файл
}
#-Функция сохранения текущих параметров--------------------------------------------------------------------------------------------------------------------------------------------
_SAVE () {
  [ "${RAZD}" = '' ] && _CLEAR              # если мы еще и не вошли в раздел (т.е. мы выбрали какую-то строку выполнения
  echo "ARROW=q" >> ${TMP_MENU}             # запишем определение кода клавиши как бред во временный файл
  echo "STEP=${STEP}" >> ${TMP_MENU}        # запишем определение выбранного пункта меню как текущее во временный файл
  echo "LINE=${LINE}" >> ${TMP_MENU}        # запишем определение выбранной строки как текущее во временный файл
  echo -n "UP='" >> ${TMP_MENU}             # запишем определение заголовка без переноса строки, без значения и закрывающей кавычки! во временный файл
  echo -n ${UP} >> ${TMP_MENU}              # запишем текущее значение заголовка во временный файл без переноса строки
  echo \' >> ${TMP_MENU}                    # запишем закрывающую кавычку и перенос строки во временный файл
                                            # вся эта хрень нужна для того, чтобы корректно обрабатывать заголовок из нескольких слов
  echo -n "COMMENT='" >> ${TMP_MENU}        # проделаем такую же фиготню
  echo -n ${COMMENT} >> ${TMP_MENU}         # с описанием
  echo \' >> ${TMP_MENU}                    # выбранного пункта
  echo 'TEXT=$2'>> ${TMP_MENU}              # запишем определение подписей пунктов меню как второй параметр строки запуска во временный файл
  [ -f ${TMP_MENU} -a ${STEP} -eq 0 ] && _CLEAR  # можно забыть то, что относится к текущему меню (так как мы из него выходим)
  RAZD=''                                   # сбросим признак открытия раздела
}
#-Запускающая функция--------------------------------------------------------------------------------------------------------------------------------------------------------------
_MENU () {
  tput civis                                                  # уберем отображение стандартного курсора
  if [ -f ${TMP_MENU} ]                                       # если временный файл существует (т.е. мы уже запускали меню)
    then                                                        # то
      . ${TMP_MENU}                                               # вспомним, что мы тогда делали
      [ "${RAZD}" != '' ] && . ${LIB_DIR}/menu.var                # если при этом мы открыли раздел, то для открытого раздела сбросим переменные в изначальные
    else                                                        # иначе (первый! запуск корневого! меню)
      . ${LIB_DIR}/menu.var                                       # подгрузим файлик с необходимыми нам переменными
  fi                                                          # конец условия
  _PRINT                                                      # отрисуем меню
  _CURSOR                                                     # отобразим наш курсор
  _CASE                                                       # выберем пункт меню
  _SAVE                                                       # запомним все
  tput cup $((${COUNT_MENU}+10)) 0                            # чтобы не накладывать командную строку BASH после выхода, поместим курсор далеко под наше меню.
  tput cnorm                                                  # вернем отображение стандартного курсора
}
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
